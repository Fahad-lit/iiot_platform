"""\nØ®Ø¯Ù…Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆØ§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ (ML Service)\nProvides AI/ML capabilities for predictive maintenance and anomaly detection\n"""\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Tuple\nimport numpy as np\nfrom sklearn.ensemble import IsolationForest, RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nimport pickle\nimport os\nfrom database.influxdb_db import query_measurements\nfrom database.mongodb_db import get_mongodb_connection\n\nlogger = logging.getLogger(__name__)\n\nclass MLService:\n    \"\"\"Ø®Ø¯Ù…Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆØ§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ\"\"\"\n    \n    def __init__(self):\n        self.models_dir = \"./ml_models\"\n        self._ensure_models_dir()\n        self.scaler = StandardScaler()\n        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)\n        self.failure_predictor = None\n    \n    def _ensure_models_dir(self):\n        \"\"\"Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬\"\"\"\n        if not os.path.exists(self.models_dir):\n            os.makedirs(self.models_dir)\n            logger.info(f\"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬: {self.models_dir}\")\n    \n    async def predict_device_failure(\n        self,\n        device_id: str,\n        measurement_type: str,\n        time_range: str = \"-30d\"\n    ) -> Dict[str, Any]:\n        \"\"\"Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø£Ø¹Ø·Ø§Ù„ Ø§Ù„Ø¬Ù‡Ø§Ø²\"\"\"\n        try:\n            logger.info(f\"ğŸ¤– Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø£Ø¹Ø·Ø§Ù„ Ø§Ù„Ø¬Ù‡Ø§Ø²: {device_id}\")\n            \n            # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©\n            measurements = await query_measurements(measurement_type, device_id, time_range)\n            \n            if len(measurements) < 10:\n                return {\n                    \"device_id\": device_id,\n                    \"message\": \"Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ© Ù„Ù„ØªÙ†Ø¨Ø¤\",\n                    \"confidence\": 0\n                }\n            \n            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‚ÙŠÙ…\n            values = np.array([m['value'] for m in measurements if isinstance(m['value'], (int, float))])\n            \n            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª\n            trend = self._calculate_trend(values)\n            volatility = np.std(values)\n            degradation_rate = self._calculate_degradation_rate(values)\n            \n            # Ø­Ø³Ø§Ø¨ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„ÙØ´Ù„\n            failure_probability = self._calculate_failure_probability(\n                trend, volatility, degradation_rate\n            )\n            \n            # ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠØ§Ù… Ø­ØªÙ‰ Ø§Ù„ÙØ´Ù„ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹\n            days_to_failure = self._estimate_days_to_failure(\n                degradation_rate, failure_probability\n            )\n            \n            prediction = {\n                \"device_id\": device_id,\n                \"measurement_type\": measurement_type,\n                \"failure_probability\": round(failure_probability, 3),\n                \"confidence\": round(min(len(measurements) / 100, 1.0), 2),\n                \"days_to_failure\": max(1, int(days_to_failure)),\n                \"risk_level\": self._determine_risk_level(failure_probability),\n                \"recommendations\": self._generate_recommendations(failure_probability),\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n            logger.info(f\"âœ… ØªÙ… Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ù†Ø¬Ø§Ø­: Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„ÙØ´Ù„ = {failure_probability:.1%}\")\n            return prediction\n        \n        except Exception as e:\n            logger.error(f\"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ†Ø¨Ø¤: {str(e)}\")\n            return {\n                \"error\": str(e),\n                \"device_id\": device_id\n            }\n    \n    async def predict_maintenance_schedule(\n        self,\n        device_id: str,\n        measurement_type: str\n    ) -> Dict[str, Any]:\n        \"\"\"Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„ÙˆÙ‚Ø§Ø¦ÙŠØ©\"\"\"\n        try:\n            logger.info(f\"ğŸ”§ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØµÙŠØ§Ù†Ø© Ù„Ù„Ø¬Ù‡Ø§Ø²: {device_id}\")\n            \n            # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n            measurements = await query_measurements(measurement_type, device_id, \"-60d\")\n            \n            if not measurements:\n                return {\n                    \"device_id\": device_id,\n                    \"message\": \"Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©\"\n                }\n            \n            # Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¯Ù‡ÙˆØ±\n            values = np.array([m['value'] for m in measurements if isinstance(m['value'], (int, float))])\n            degradation_rate = self._calculate_degradation_rate(values)\n            \n            # Ø­Ø³Ø§Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­\n            days_until_maintenance = max(7, int(30 / (degradation_rate + 0.1)))\n            maintenance_date = datetime.now() + timedelta(days=days_until_maintenance)\n            \n            maintenance_schedule = {\n                \"device_id\": device_id,\n                \"measurement_type\": measurement_type,\n                \"suggested_maintenance_date\": maintenance_date.isoformat(),\n                \"days_until_maintenance\": days_until_maintenance,\n                \"degradation_rate\": round(degradation_rate, 3),\n                \"maintenance_type\": self._determine_maintenance_type(degradation_rate),\n                \"estimated_duration_hours\": self._estimate_maintenance_duration(degradation_rate),\n                \"priority\": self._determine_priority(degradation_rate),\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n            logger.info(f\"âœ… ØªÙ… Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØµÙŠØ§Ù†Ø©\")\n            return maintenance_schedule\n        \n        except Exception as e:\n            logger.error(f\"âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØµÙŠØ§Ù†Ø©: {str(e)}\")\n            return {\"error\": str(e)}\n    \n    async def detect_anomalies_ml(\n        self,\n        device_id: str,\n        measurement_type: str,\n        contamination: float = 0.1\n    ) -> Dict[str, Any]:\n        \"\"\"ÙƒØ´Ù Ø§Ù„Ø´Ø°ÙˆØ° Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Isolation Forest\"\"\"\n        try:\n            logger.info(f\"ğŸ” ÙƒØ´Ù Ø§Ù„Ø´Ø°ÙˆØ° Ù„Ù„Ø¬Ù‡Ø§Ø²: {device_id}\")\n            \n            # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n            measurements = await query_measurements(measurement_type, device_id, \"-7d\")\n            \n            if len(measurements) < 10:\n                return {\n                    \"device_id\": device_id,\n                    \"message\": \"Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©\"\n                }\n            \n            # ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n            values = np.array([m['value'] for m in measurements if isinstance(m['value'], (int, float))]).reshape(-1, 1)\n            \n            # ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n            values_scaled = self.scaler.fit_transform(values)\n            \n            # ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ ÙƒØ´Ù Ø§Ù„Ø´Ø°ÙˆØ°\n            detector = IsolationForest(contamination=contamination, random_state=42)\n            predictions = detector.fit_predict(values_scaled)\n            scores = detector.score_samples(values_scaled)\n            \n            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø°ÙˆØ°\n            anomalies = []\n            for i, (pred, score) in enumerate(zip(predictions, scores)):\n                if pred == -1:  # Ø´Ø°ÙˆØ°\n                    anomalies.append({\n                        \"index\": i,\n                        \"value\": float(values[i][0]),\n                        \"anomaly_score\": round(float(score), 3),\n                        \"severity\": \"high\" if score < -0.5 else \"medium\"\n                    })\n            \n            result = {\n                \"device_id\": device_id,\n                \"measurement_type\": measurement_type,\n                \"total_measurements\": len(values),\n                \"anomalies_detected\": len(anomalies),\n                \"anomalies\": anomalies,\n                \"contamination_rate\": contamination,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n            logger.info(f\"âœ… ØªÙ… ÙƒØ´Ù {len(anomalies)} Ø´Ø°ÙˆØ°\")\n            return result\n        \n        except Exception as e:\n            logger.error(f\"âŒ Ø®Ø·Ø£ ÙÙŠ ÙƒØ´Ù Ø§Ù„Ø´Ø°ÙˆØ°: {str(e)}\")\n            return {\"error\": str(e)}\n    \n    def _calculate_trend(self, values: np.ndarray) -> float:\n        \"\"\"Ø­Ø³Ø§Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\"\"\"\n        if len(values) < 2:\n            return 0\n        \n        x = np.arange(len(values))\n        coefficients = np.polyfit(x, values, 1)\n        return coefficients[0]\n    \n    def _calculate_degradation_rate(self, values: np.ndarray) -> float:\n        \"\"\"Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¯Ù‡ÙˆØ±\"\"\"\n        if len(values) < 2:\n            return 0\n        \n        # Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØºÙŠØ±\n        diffs = np.diff(values)\n        positive_diffs = np.sum(diffs > 0)\n        negative_diffs = np.sum(diffs < 0)\n        \n        # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª Ù…ØªÙƒØ±Ø±Ø©ØŒ ÙÙ‡Ø°Ø§ ÙŠØ´ÙŠØ± Ø¥Ù„Ù‰ ØªØ¯Ù‡ÙˆØ±\n        degradation = abs(negative_diffs - positive_diffs) / len(diffs) if len(diffs) > 0 else 0\n        return degradation\n    \n    def _calculate_failure_probability(self, trend: float, volatility: float, degradation_rate: float) -> float:\n        \"\"\"Ø­Ø³Ø§Ø¨ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„ÙØ´Ù„\"\"\"\n        # Ø¯Ø§Ù„Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø¥Ù„Ù‰ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© (0-1)\n        trend_factor = min(abs(trend) * 10, 1.0)\n        volatility_factor = min(volatility / 100, 1.0)\n        degradation_factor = min(degradation_rate * 2, 1.0)\n        \n        # Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø±Ø¬Ø­\n        probability = (trend_factor * 0.3 + volatility_factor * 0.3 + degradation_factor * 0.4)\n        return min(probability, 1.0)\n    \n    def _estimate_days_to_failure(self, degradation_rate: float, failure_probability: float) -> float:\n        \"\"\"ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… Ø­ØªÙ‰ Ø§Ù„ÙØ´Ù„ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹\"\"\"\n        if degradation_rate <= 0:\n            return 365\n        \n        # ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¯Ù‡ÙˆØ±ØŒ Ù‚Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù…\n        days = 30 / (degradation_rate + 0.1) * (1 - failure_probability)\n        return max(1, days)\n    \n    def _determine_risk_level(self, failure_probability: float) -> str:\n        \"\"\"ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·Ø±\"\"\"\n        if failure_probability >= 0.7:\n            return \"critical\"\n        elif failure_probability >= 0.5:\n            return \"high\"\n        elif failure_probability >= 0.3:\n            return \"medium\"\n        else:\n            return \"low\"\n    \n    def _generate_recommendations(self, failure_probability: float) -> List[str]:\n        \"\"\"ØªÙˆÙ„ÙŠØ¯ ØªÙˆØµÙŠØ§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„ÙØ´Ù„\"\"\"\n        recommendations = []\n        \n        if failure_probability >= 0.7:\n            recommendations.append(\"âš ï¸ Ø¬Ø¯ÙˆÙ„ ØµÙŠØ§Ù†Ø© ÙÙˆØ±ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©\")\n            recommendations.append(\"âš ï¸ Ù…Ø±Ø§Ù‚Ø¨Ø© Ù…Ø³ØªÙ…Ø±Ø© Ù„Ù„Ø¬Ù‡Ø§Ø²\")\n        elif failure_probability >= 0.5:\n            recommendations.append(\"ğŸ“… Ø¬Ø¯ÙˆÙ„ ØµÙŠØ§Ù†Ø© Ø®Ù„Ø§Ù„ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù…\")\n            recommendations.append(\"ğŸ“Š Ø²ÙŠØ§Ø¯Ø© ØªÙƒØ±Ø§Ø± Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©\")\n        elif failure_probability >= 0.3:\n            recommendations.append(\"ğŸ“… Ø¬Ø¯ÙˆÙ„ ØµÙŠØ§Ù†Ø© ÙˆÙ‚Ø§Ø¦ÙŠØ©\")\n            recommendations.append(\"âœ… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¯ÙˆØ±ÙŠØ© ÙƒØ§ÙÙŠØ©\")\n        else:\n            recommendations.append(\"âœ… Ø§Ù„Ø¬Ù‡Ø§Ø² ÙÙŠ Ø­Ø§Ù„Ø© Ø¬ÙŠØ¯Ø©\")\n            recommendations.append(\"âœ… Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø¯ÙˆØ±ÙŠØ©\")\n        \n        return recommendations\n    \n    def _determine_maintenance_type(self, degradation_rate: float) -> str:\n        \"\"\"ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©\"\"\"\n        if degradation_rate > 0.5:\n            return \"preventive_major\"\n        elif degradation_rate > 0.3:\n            return \"preventive_standard\"\n        else:\n            return \"preventive_routine\"\n    \n    def _estimate_maintenance_duration(self, degradation_rate: float) -> float:\n        \"\"\"ØªÙ‚Ø¯ÙŠØ± Ù…Ø¯Ø© Ø§Ù„ØµÙŠØ§Ù†Ø© Ø¨Ø§Ù„Ø³Ø§Ø¹Ø§Øª\"\"\"\n        if degradation_rate > 0.5:\n            return 8.0\n        elif degradation_rate > 0.3:\n            return 4.0\n        else:\n            return 2.0\n    \n    def _determine_priority(self, degradation_rate: float) -> str:\n        \"\"\"ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„ØµÙŠØ§Ù†Ø©\"\"\"\n        if degradation_rate > 0.5:\n            return \"urgent\"\n        elif degradation_rate > 0.3:\n            return \"high\"\n        else:\n            return \"normal\"\n\n# Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ù† Ø§Ù„Ø®Ø¯Ù…Ø©\nml_service = MLService()\n
